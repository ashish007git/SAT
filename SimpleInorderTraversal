//============================================================================
// Name        : SAT.cpp
// Author      : Vignesh Raghavan
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

/* BASIC DLL ALGORITHM
 * Clause Satisfied/Unsatisfied checks.
 * Clause update.
 * Variable Selection and Assignment.
 * BCP forced decision identification.
 * Conflict identification.
 * Backtracking chronologically to the parent node.
 */

#include <iostream>
#include <stack>
#include <queue>
using namespace std;


typedef struct Lit
{
	int id;
	bool val; // 75% in memory savings wi.re.to (int) val variable. Easy to check SAT/UNSAT by ORring literals.

	bool assigned; //assigned = true => value assigned to the variable.
	bool visited; //visited = true => backtrack to parent.
	bool forced; //forced = true => forced decision.
}Lit;


void display(Lit *l, int num)
{
	for(int i=0; i<num; i++)
	{
		cout<<l[i].id<<" = "<<l[i].val<<"\n";
	}
	cout<<"\n\n";
}

void IterativeTraversal(Lit *l, int num)
{
	Lit* temp;
	stack<Lit*> S;

	//Start from l[0]
	S.push(l);
	int j = 0;
	bool backtrack = false;
	while(! S.empty())
	{
		temp = S.top();

		if(temp->visited == false)
		{
			if(backtrack == false)
			{
				temp->val = false; //Value computed while making a free decision. How to equate from previous iteration?
			}
			else
			{
				backtrack = false;
				temp->val = !(temp->val); //Toggle the value assigned upon backtracking.
				temp->visited = true;
			}

			//Update the value of the complement of the literal.
			//Classify Satisfied and Unsatisfied clauses with current assignment.
			//Find forced decisions and populate the queue.
			//Pop the head of the queue, (if not empty) and push it into the stack.
			//If queue empty, pick a variable based on heuristics and select its value.
			//And, push it into the stack as the next free decision.

			if(j == num-1)
			{
				backtrack = true;
				display(l,num);
			}

			if(j < num-1)
			{
				S.push(temp+1); //Push Next variable computed before (free/forced decision).
				j++;
			}
		}
		else
		{
			backtrack = true;
			temp->visited = false;
			//temp->val = false;
			S.pop();
			j--;
		}
	}
}


int main()
{
	int num = 5;
	Lit x;
	Lit m[num];

	//Push- S.push(x)
	//Access top- x = S.top()
	//Pop- S.pop()
	//Check empty- S.empty()

	//Push- Q.push(x)
	//Access first element- Q.front()
	//Pop- Q.pop()
	//Check empty- Q.empty()

	for(int i=0; i<num; i++)
	{
		x.id = i+1;
		x.val = false;
		x.assigned = false;
		x.visited = false;
		x.forced = false;
		m[i] = x;
	}

	IterativeTraversal(m, num);

	/*for(int i=0; i<num; i++)
	{
		cout<<"m[i].id = "<<m[i].id<<" m[i].val = "<<m[i].val<<"\n";
	}*/

	return 0;
}
