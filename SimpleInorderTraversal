//============================================================================
// Name        : SAT.cpp
// Author      : Vignesh Raghavan
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

/* BASIC DLL ALGORITHM
 * Clause Satisfied/Unsatisfied checks.
 * Clause update.
 * Variable Selection and Assignment.
 * BCP forced decision identification.
 * Conflict identification.
 * Backtracking chronologically to the parent node.
 */

#include <iostream>
#include <stack>
#include <queue>
using namespace std;


typedef struct Lit
{
	int id;
	bool val; // 75% in memory savings wi.re.to (int) val variable. Easy to check SAT/UNSAT by ORring literals.

	bool assigned; //assigned = true => value assigned to the variable.
	bool visited; //visited = true => backtrack to parent.
	bool forced; //forced = true => forced decision.
}Lit;


void display(Lit *l, int num)
{
	for(int i=0; i<num; i++)
	{
		cout<<l[i].id<<" = "<<l[i].val<<"\n";
	}
	cout<<"\n\n";
}

void IterativeTraversal(Lit *l, int num)
{
	Lit T[num];
	Lit temp;
	stack<Lit> S;

	for(int i=0; i<num; i++)
	{
		T[i] = l[i];
		//cout<<T[i].id<<".."<<T[i].val<<"\n";
	}

	//Start from l[0]
	S.push(T[0]);
	int j = 0;
	bool backtrack = false;
	while(! S.empty())
	{
		temp = S.top();
		S.pop(); //Need to reflect proper value and state of the literals always in the stack. Hence, POP->Update->PUSH.

		if(temp.visited == false)
		{
			if(backtrack == false)
			{
				temp.val = false; //Value computed while making a free decision. How to equate from previous iteration?
			}
			else
			{
				backtrack = false;
				temp.val = !(temp.val); //Toggle the value assigned upon backtracking.
				temp.visited = true;
			}

			T[j] = temp;
			S.push(temp);

			//Update the value of the complement of the literal.
			//Classify Satisfied and Unsatisfied clauses with current assignment.
			//Find forced decisions and populate the queue.
			//Pop the head of the queue, (if not empty) and push it into the stack.
			//If queue empty, pick a variable based on heuristics and select its value.
			//And, push it into the stack as the next free decision.

			if(j == num-1)
			{
				backtrack = true;
				display(T,num);
			}

			if(j < num-1)
			{
				S.push(T[j+1]); //Push Next variable computed before (free/forced decision).
				j++;
			}
		}
		else
		{
			backtrack = true;
			temp.visited = false;
			temp.val = false;
			T[j] = temp;
			j--;
		}
	}
}


int main()
{
	stack<Lit> S;
	Lit x;
	int num = 5;
	Lit m[num];
	//queue<Lit> Q;

	//Push- S.push(x)
	//Access top- x = S.top()
	//Pop- S.pop()
	//Check empty- S.empty()

	//Push- Q.push(x)
	//Access first element- Q.front()
	//Pop- Q.pop()
	//Check empty- Q.empty()

	for(int i=0; i<num; i++)
	{
		x.id = i+1;
		x.val = false;
		x.assigned = false;
		x.visited = false;
		x.forced = false;
		S.push(x);
		m[i] = x;
		//Q.push(x);
	}
	IterativeTraversal(m, num);

	/*for(int i=0; i<num; i++)
	{
		//x = S.top();
		x = Q.front();
		cout<<"x.id = "<<x.id<<" x.val = "<<x.val<<"\n";
		//S.pop();
		Q.pop();
	}

	if(Q.empty())//S.empty())
	{
		cout<<"Queue/Stack Empty!\n";
	}*/

	return 0;
}
