//============================================================================
// Name        : SAT.cpp
// Author      : Vignesh Raghavan
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

/* BASIC DLL ALGORITHM
 * Clause Satisfied/Unsatisfied checks.
 * Clause update.
 * Variable Selection and Assignment.
 * BCP forced decision identification.
 * Conflict identification.
 * Backtracking chronologically to the parent node.
 */

#include <iostream>
#include <stack>
using namespace std;


typedef struct Lit
{
	int id;
	int val;

	bool visited;
	bool forced;
}Lit;


void display(Lit *l, int num)
{
	for(int i=0; i<num; i++)
	{
		cout<<l[i].id<<" = "<<l[i].val<<"\n";
	}
	cout<<"\n\n";
}

int DFS(Lit *l, int num)
{
	Lit T[num];
	Lit temp;
	stack<Lit> S;

	for(int i=0; i<num; i++)
	{
		T[i] = l[i];
		//cout<<T[i].id<<".."<<T[i].val<<"\n";
	}

	//Start from l[0]
	S.push(T[0]);
	int j = 0;
	int k = 1;
	while(! S.empty())
	{
		temp = S.top();
		S.pop(); //Need to reflect proper value and state of the literals always in the stack. Hence, POP->Update->PUSH.

		if(temp.visited == false)
		{
			if(temp.val == 2)
			{
				temp.val = 0; //Value computed while making a free decision. How to equate from previous iteration?
			}
			else
			{
				temp.val = (~temp.val) & 0x1; //Toggle the value assigned upon backtracking.
				temp.visited = true;
			}

			T[j] = temp;
			S.push(temp);
			if(k == 0) display(T, num);

			//Classify Satisfied and Unsatisfied clauses with current assignment.
			//Find forced decisions and populate the queue.
			//Pop the head of the queue, (if not empty) and push it into the stack.
			//If queue empty, pick a variable based on heuristics.
			//And, push it into the stack as the next free decision.

			if(j < num-1)
			{
				S.push(T[j+1]); //Push Next variable computed before (free/forced decision).
				j++;
			}
		}
		else
		{
			temp.visited = false;
			temp.val = 2;
			T[j] = temp;
			j--;
			k=1;
		}

		if(j==num-1)
		{
			k = 0;
		}
	}

	return 0;
}


int main()
{
	stack<Lit> S;
	Lit x;
	int num = 5;
	Lit m[num];

	//Push- S.push(x)
	//Access top- x = S.top()
	//Pop- S.pop()

	for(int i=0; i<num; i++)
	{
		x.id = i+1;
		x.val = 2;
		x.visited = false;
		x.forced = false;
		S.push(x);
		m[i] = x;
	}
	int y = DFS(m, num);

	/*for(int i=0; i<num; i++)
	{
		x = S.top();
		cout<<"x.id = "<<x.id<<"x.val = "<<x.val<<"\n";
		S.pop();
	}

	if(S.empty())
	{
		cout<<"Stack Empty!\n";
	}*/

	return 0;
}
